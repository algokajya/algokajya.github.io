<!DOCTYPE html>
<html lang="ja">
<head>
   <meta charset="UTF-8">
   <title>AlgoKajya Guile色々／POSIX拡張正規表現</title>
   <link rel="stylesheet" type="text/css" href="gm.css">
   <!-- %%% MathJax %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
   <!--
   <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
   -->
   <script>
   MathJax = {
      chtml: {
         matchFontHeight: false
      },
      tex: {
         inlineMath: [['$', '$'],['\\(', '\\)']]
      }
   };
   </script>
   <!--
   <script id="MathJax-script" async 
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
   </script>
   -->
   <script id="MathJax-script" async 
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
   </script>
   <!-- %%% date %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
   <!--
   <style>
      .date1:before{ content: "2021.12.29"; }
      .date0:before{ content: "2021.12.28"; }
   </style>
   -->
</head>


<body id="page-top">

<!-- %%% header %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<div id="header">
<span class="nolink">[Prev]</span>
&ensp; 
<a class="noline" href="index.html">[Up]</a>
&ensp; 
<a class="noline" href="regex-proc.html">[Next]</a>
&ensp; 
<a class="noline" href="../index.html">ホーム</a><br>
</div>



<!-- %%% title %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<div id="title">
Guile色々／POSIX拡張正規表現
</div>


<!-- %%% change log %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<p></p>
<div id="revise">
<h4 class="revise">変更履歴</h4>
<ul class="revise">
<li class="revise">
<span class="mydate">2022.1.15</span>：CSSを一部変更．
<li class="revise">
<span class="mydate">2022.1.8</span>：HTMLの誤りを訂正．
<li class="revise">
<span class="mydate">2022.1.6</span>：マッチに関する用語を追加．
<li class="revise">
<span class="mydate">2021.12.29</span>：最後の実行例を訂正．
<li class="revise">
<span class="mydate">2021.12.28</span>：初出
</ul>
</div>


<!-- %%% abstract %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<div id="abstract">
<h4 class="hdln">概 要</h4>
<ul>
<li>
Guileは<em>POSIXの拡張正規表現</em>（POSIX Extended Regular Expression；以下，<em>POSIX.ERE</em>）をサポートしています．内部的には，Gnu Cの正規表現ライブラリを使用しているそうです．このノートは以下の2つの資料に基づいてPOSIX.EREについて勉強したことを記録しています．
   <ul>
   <li> <a  class="noline" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">
The Open Groupが公開しているPOSIX.1正規表現の仕様書</a>
   <li> <a class="noline" href="https://manpages.debian.org/testing/manpages/regex.7.en.html">LinuxオンラインマニュアルのPOSIX.2正規表現</a>
   </ul>
POSIX.1とPOSIX.2とでは，微妙な違いがありますが，大きな違いはありません．
<li>
このノートで述べていることは，すべて，Guileで使用することを前提にしています．仕様書やオンラインマニュアルに述べられていない機能（基本正規表現で利用可能な機能など）が利用できるかどうかについては，Guileのstring-match手続きを使って調査しています．ですから，他のコマンド等（grepやsedなど）には当てはまらないかも知れません．
<li>
正規表現の幾つかの機能はロケールに依存して変化します（<a class="noline" href="#on-locale">ロケールについて</a>を参照）．
以下の説明は筆者の環境（Debian 11）のロケール（ja_JP.UTF-8）に基づいています．
</ul>
</div>


<!-- %%%%%%%%%%%%%% -->
<!-- %%% 目　次 %%% -->
<!-- %%%%%%%%%%%%%% -->
<div id="contents">
<h4 class="hdln">目 次</h4>
<ul class="menu">
<li class="menu"><a class="noline" href="#preliminaries">準備</a>
   <ul class="menu">
   <li class="menu">
   <a class="noline" href="#math-symbols">文字列に関する数学的な記法</a>
   <li class="menu">
   <a class="noline" href="#color-of-regular-expression">正規表現の色分けについて</a>
   <li class="menu">
   <a class="noline" href="#on-matches">マッチについて</a>
   <li class="menu">
   <a class="noline" href="#beginning-end-edge">先頭，末尾，境界</a>
   </ul>
<li class="menu">
<a class="noline" href="#POSIX.ERE">POSIX拡張正規表現（POSIX.ERE）</a>
   <ul class="menu">
   <li class="menu">
      <a class="noline" href="#characters-in-POSIX.ERE">POSIX.EREにおける文字の分類</a>
   <li class="menu">
      <a class="noline" href="#description-of-POSIX.ERE">POSIX.EREの記述形式</a> 
   <li class="menu">
      <a class="noline" href="#grammer-of-POSIX.ERE">POSIX.EREの文法</a>
   </ul>
<li class="menu"><a class="noline" href="#bracket-expression">ブラケット表現（bracket expression）</a>
   <ul class="menu">
   <li class="menu">
   <a class="noline" href="#description-of-bracket-expression">ブラケット表現の記述形式</a>
   <li class="menu">
   <a class="noline" href="#characeters-in-bracket-expression">ブラケット表現における文字の分類</a>
   <li class="menu">
   <a class="noline" href="#collating-symbol">照合記号表現</a>
   <li class="menu">
   <a class="noline" href="#equivalence-class">等価クラス表現</a>
   <li class="menu">
   <a class="noline" href="#character-class">文字クラス表現</a>
   <li class="menu">
   <a class="noline" href="#range-expression">範囲表現</a>
   <li class="menu">
   <a class="noline" href="#on-hyphen">ハイフンについて</a>
   <li class="menu">
   <a class="noline" href="#grammar-bracket-expression">ブラケット表現の文法</a>
   </ul>
<li class="menu">
<a class="noline" href="#miscellaneous">その他色々</a>
   <ul>
   <li class="menu">
   <a class="noline" href="#on-locale">ロケールについて</a>
   <li class="menu">
   <a class="noline" href="#on-quoted-characters">クォートされた文字について</a>
   <li class="menu">
   <a class="noline" href="#on-back-reference">前方参照（back-reference）について</a>
   </ul>
<!--
<li class="menu">
<a class="noline" href="#revise">変更履歴</a>
-->
</ul>
</div>


<!-- %%%%%%%%%%%%%%%% -->
<!-- %%% 参考資料 %%% -->
<!-- %%%%%%%%%%%%%%%% -->
<div id="references">
<h4 class="hdln">参考資料</h4>
<ul>
<li>
Guile, Scheme
<ul class="menu">
<li class="menu">
<a class="noline" href="https://www.gnu.org/software/guile/manual/">
GNU Guile Reference Manual（最新版）
</a>
<li class="menu"> 
<a class="noline" href="https://raw.githubusercontent.com/algokajya/Scheme-Guile/Scheme/guile-manual-3.0.5.pdf">
GNU Guile Reference Manual（Edition 3.0.5, revision 1）
</a>
</ul>
<li>
POSIX正規表現
<ul>
<li class="menu">
<a class="noline" href="
https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html
">
POSIX.1正規表現（The Open Group Base Specifications Issue 7, 2018 edition IEEE Std 1003.1-2017: Regular Expression）
</a>
<li class="menu"> 
<a class="noline" href="
https://manpages.debian.org/testing/manpages/regex.7.en.html
">POSIX.2正規表現（Linux Programmer&apos;s Manual: man -s7 regex &crarr; ）</a>
<li class="menu"> 
<a class="noline" 
   href="https://qiita.com/ko1nksm/items/53abc144558b9bb5629f
">
正しく理解できる！シェルスクリプトとPOSIXの正規表現（令和最新版）
</a>
<li class="menu"> 
<a class="noline" href="
https://www.gnu.org/software/libc/manual/html_node/Regular-Expressions.html#Regular-Expressions
">The GNU C Library Reference Manual, for version 2.34：Regular Expression Matching</a>
<li class="menu"> 
<a class="noline" href="
https://manpages.debian.org/testing/manpages-dev/regex.3.en.html
">POSIX regex functions（Linux Programmer&apos;s Manual: man -s3 regex &crarr;）</a>
</ul>
<li>
ロケール，Unicode
<ul>
<li class="menu"> 
<a class="noline" href="
https://manpages.debian.org/testing/manpages/locale.5.en.html
">
Linux User Manual: man -s5 locale &crarr;　（locale - describes a locale definition file）
</a>
<li class="menu"> 
<a class="noline" href="
https://home.unicode.org/
">
Unicode consortium
</a><br>
<a class="noline" href="
https://unicode.org/main.html
">
Unicode Technical Site
</a>
<li class="menu"> 
<a class="noline" href="
https://decodeunicode.org/
">
decodeunicode – the world’s writing systems
</a><br>
<a class="noline" href="
https://ja.wikipedia.org/wiki/Unicode%E4%B8%80%E8%A6%A7%E8%A1%A8
">
Unicode一覧表（ウィキペディア）
</a>
</ul>
<li class="menu"> 
（注意）このノートはMathJaxを使用しています．
   <ul class="menu">
   <li class="menu"> 
   <a class="noline" href="https://oku.edu.mie-u.ac.jp/~okumura/javascript/mathjax.html">奥村晴彦先生のMathJaxのページ</a>（筆者はこの説明の通りに設定しています）
   <li class="menu"> 
   <a class="noline" href="https://www.mathjax.org/">MathJax本家</a>
   </ul>      
</ul>
</div>




<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%% main contents %%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<div id="main">

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section>
<h3 class="section" id="preliminaries">準備</h3>

<!-- ============================================= -->
<h4 class="hdln" id="math-symbols">文字列に関する数学的な記法</h4>
<ul>
<li>
正規表現（regular expression）は，元来，文字列の集合を数学的に定義するためのものです．このノートでは，POSIX.EREの意味を，それが表現している文字列の集合によって示します．そのため次のような数学的な記法を使用します．以下の$x$や$y$は文字列を表し，$A$や$B$は文字列からなる集合を表しています．
<table class="symbol">
   <tr>
      <th>記法</th> <th>意味</th>
   </tr>
   <tr>
      <td>$\Sigma$</td> <td>すべての文字からなる集合（文字の全体集合）</td>
   </tr>
   <tr>
      <td>$\Sigma^*$</td> <td>すべての文字列からなる集合（文字列の全体集合）</td>
   </tr>
   <tr>
      <td>$x \cdot y$</td> 
      <td>$x$のうしろに$y$を連結する．Schemeのstring-appendのこと．<br>
連結演算に関して $(x\cdot{}y)\cdot{}z = x\cdot(y\cdot{}z)$（結合律）が成り立つので，<br>
連結演算の間の優先順位を指定する丸括弧は省略します．
      </td>
   </tr>
   <tr>
      <td>$\varepsilon$</td> <td>空文字列（長さが0の文字列）．Schemeにおいて "" と表される文字列のこと．<br>
空文字列と任意の文字列$x$に対して $x\cdot\varepsilon = \varepsilon\cdot{}x = x$ が成り立ちます．</td>
   </tr>
   <tr>
      <td>$x^n$</td> 
      <td>$x\cdot{}x\cdot{}\,\ldots\,\cdot{}x$&nbsp;（$n$個の$x$を連結）<br>
      正確な定義は次の通り．
      <ul>
      <li>
      $x^0=\varepsilon$; $x^k=x^{k-1} \cdot x$（$k \geq 1$）
      </ul>
      </td>
   </tr>
   <tr>
      <td>$A \cup B$</td> <td>$A$と$B$の和集合</td>
   </tr>
   <tr>
      <td>$A \cap B$</td> <td>$A$と$B$の共通部分</td>
   </tr>
   <tr>
      <td>$A - B$</td> <td>$A$と$B$の差集合</td>
   </tr>
   <tr>
      <td>$A \cdot B$</td> 
      <td>$\{ x \cdot y \mid x \in A, y \in B \}$</td>
   </tr>
   <tr>
      <td>$A^n$</td> 
      <td>$\{ x_1 \cdot x_2 \cdot ~...~ \cdot x_n \mid x_1 \in A, x_2 \in A, ~...~, x_n \in A \}$<br>
      正確な定義は次の通り．
      <ul>
      <li> $A^0=\{\varepsilon\}$; $A^k = A^{k-1} \cdot A$（$k \geq 1$）
      </ul>
      </td>
   </tr>
   <tr>
      <td>$A^*$</td> 
      <td>$\bigcup_{n \geq 0} A^n = A^0 \cup A^1 \cup A^2 \cup ~...$</td> 
   </tr>
   <tr>
      <td>$A^+$</td> 
      <td>$\bigcup_{n \geq 1} A^n = A^1 \cup A^2 \cup A^3 \cup ~...$</td> 
   </tr>
   <tr>
      <td>$L(\alpha)$</td> 
      <td>正規表現$\alpha$が表す文字列の集合</td> 
   </tr>
</table>
<li>
$\Sigma$はロケールに応じて変化します．筆者の環境（日本語版のDebian 11）ではja_JP.UTF-8で定義されているすべての文字からなる集合になります．
</ul>

<!-- ================================================ -->
<h4 class="hdln" id="color-of-regular-expression">正規表現の色分けについて</h4>
<ul>
<li>
正規表現の中で使用する文字（例えば，英字のaなど）は，単なる文字を表しているのではなく，その文字からなる集合（例えば，$\{$a$\}$など）を表しています．プログラミングに比喩して言うと，正規表現の中で使用する文字と文字列データの中で使用する文字はデータ型が異なるのです．そのため，オートマトン理論や形式言語理論の教科書では，データ型の違いを明記するために，正規表現の中の文字を太字で示したりしています．
<li>
このノートでは，<strong>正規表現を色を変えて示します</strong>．例えば，abcという文字列を正規表現として使うときには <span class="myrx">abc</span> といったように色を変えます．
</ul>

<!-- ================================================ -->
<h4 class="hdln" id="on-matches">マッチについて</h4>
<ul>
<li>
正規表現$\alpha$に文字列$z$が<em>マッチする</em>とは，$z$が$L(\alpha)$に属すること（$z \in L(\alpha)$が成り立つこと）を言います．
<li>
正規表現$\alpha$に文字列$x$を<em>マッチさせる</em>とは，$\alpha$にマッチする$x$の部分列$z$があるかどうかを探索することを言います．
<li>
正規表現に文字列をマッチさせたとき，<em>マッチが成功する</em>（<em>失敗する</em>）とは，正規表現にマッチする部分列が見つかる（見つからない）ことを言います．
<li>
文字列$x$を正規表現$\alpha$にマッチさせたとき，次のような規則に則って部分列の探索を行います．
   <ol>
   <li> 空文字列だけが$\alpha$にマッチするときには空文字列を返します．
   <li> 空文字列以外の部分列が$\alpha$にマッチするとき，$\alpha$にマッチする部分列の中で<strong>最も左に位置する部分列</strong>を返します．
   <li> ただし，「最も左に位置する部分列」が複数存在するときには，<strong>最も長い部分列</strong>を返します．
   </ol>
以上の規則を<em>最左最長原則</em>（leftmost longest rule）と呼ぶことにします．
<li>
最左最長原則は正規表現の部分式に対しても適用されます．ただし，<a class="noline" href="#on-back-reference">前方参照（back-reference）</a>を使わないのであれば，上で述べた正規表現全体に関する最左最長原則だけを気にしていればよいと言えます．詳細は省略します．
</ul>

<!-- ========================================================= -->
<h4 class="hdln" id="beginning-end-edge">先頭，末尾，境界</h4>
<ul>
<li>
以下の説明の中で，「文字列の先頭にマッチする」，「文字列の末尾にマッチする」，「境界にマッチする」といった言葉が出てきます．これらは次のように考えます．検索対象の文字列　$x=c_0c_1c_2 \,\cdots\, c_n$（各$c_i$は文字）が与えられたとき，各文字の前後に空文字列（$\varepsilon$）が付加されていて，さらに，それぞれの空文字列に文字列内の位置情報が付随していると仮定します．つまり，
   <div class="ddstyle">
   $x = \varepsilon_{(0)}\cdot{}c_0\cdot\varepsilon_{(1)}\cdot{}c_1\cdot\varepsilon_{(2)}\cdot{}c_2\cdot\varepsilon_{(3)} \,\cdots\, \varepsilon_{(n)}\cdot{}c_n\cdot\varepsilon_{(n+1)}$
   </div>
と仮定します．ここで，$\varepsilon_{(i)}$の添字$i$は空文字列の位置を示しています．この仮定のもとで：
   <ul>
   <li>
   <em>文字列$x$の先頭にマッチする</em>とは，文字列$x$の先頭にある空文字列（$\varepsilon_{(0)}$）にマッチすることを言います．
   <li> 
   <em>文字列$x$の末尾にマッチする</em>とは，文字列$x$の末尾にある空文字列（$\varepsilon_{(n+1)}$）にマッチすることを言います．
   <li>
   <em>文字列$x$の境界にマッチする</em>とは，どこかの文字の間にある空文字列（$\varepsilon_{(i)}$）にマッチすることを言います．
   <li>
<em>単語の先頭や末尾にマッチする</em>とは，単語として認識される部分列の直前や直後にある空文字列にマッチすることを言います．
   </ul>
<li>
ただし，境界にマッチするときの「どこか（空文字列の位置$i$）」は機能ごとに変化します．例えば．「単語の境界にマッチする」と言ったとき，単語（と認識される部分列）の直前にある空文字列か，単語の直後にある空文字列にマッチすることを言います．
<li>
参考のために，簡単な実行例を示します．
<pre class="shell">
$ <span class="mycmd">guile</span> 
GNU Guile 3.0.5
      ...... 起動メッセージ ......
guile> <span class="mycmd">(string-match "^" "#word#")</span> 
$1 = #("#word#" (0 . 0))
guile> <span class="mycmd">(string-match "$" "#word#")</span> 
$2 = #("#word#" (6 . 6))
guile> <span class="mycmd">(string-match "\\b" "#word#")</span> 
$3 = #("#word#" (1 . 1))
guile> 
</pre>
1番目の実行例は，「文字列の先頭にマッチする」ことを意味する正規表現 <span class="myrx">^</span> を文字列 "#word#" にマッチ（string-match）させています．その結果として0番目の空文字列（$\varepsilon_{(0)}$）がマッチしたことを示す (0 . 0) が返ってきています．2番目の実行例は「文字列の末尾にマッチする」ことを意味する正規表現 <span class="myrx">$</span> を同じ文字列にマッチ（string-match）させていて，その結果として6番目の空文字列（$\varepsilon_{(6)}$）がマッチしたことを示す (6 . 6) が返ってきています．3番目の実行例は「単語の境界にマッチする」ことを意味する正規表現 <span class="myrx">\b</span> を同じ文字列にマッチ（string-match）させています（注：バックスラッシュが2重になっているのは，Guileのreaderにバックスラッシュをエスケープさせるためです）．この場合，"word"が単語として認識されていて，その直前にある空文字列（$\varepsilon_{(1)}$）がマッチしたことを示す (1 . 1) が返ってきています．
</ul>
</section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section>
<h3 class="section" id="POSIX.ERE">POSIX拡張正規表現（POSIX.ERE）</h3>

<h4 class="hdln" id="characters-in-POSIX.ERE">POSIX.EREにおける文字</h4>
<ul>
<li>
POSIX.EREは，文字を通常文字（ordinary character）と特殊文字（special character）に分類しています．<em>通常文字</em>は特殊文字以外の文字のことです．<em>特殊文字</em>はPOSIX.EREの中で<strong>特別な機能を果たす文字</strong>のことで，以下のものがあります．
<table class="symbol">
<tr>
   <th>名称</th> <th>文字</th> <th>機能</th> 
</tr>
<tr>
   <td>ハット記号</td>
   <td><span class="myrx">^</span></td>
   <td>文字列の先頭にマッチする．</td>
</tr>
<tr>
   <td>ピリオド</td>
   <td><span class="myrx">.</span></td>
   <td>任意の1文字にマッチする．</td>
</tr>
<tr>
   <td>左角括弧</td>
   <td><span class="myrx">[</span></td>
   <td>ブラケット表現を開始する．</td>
</tr>
<tr>
   <td>ドル記号</td>
   <td><span class="myrx">$</span></td>
   <td>文字列の末尾にマッチする．</td>
</tr>
<tr>
   <td>左丸括弧</td>
   <td><span class="myrx">(</span></td>
   <td>グループ化（演算の結合順序を指定）を開始する．</td>
</tr>
<tr>
   <td>右丸括弧</td>
   <td><span class="myrx">)</span></td>
   <td>グループ化（演算の結合順序を指定）を終了する．</td>
</tr>
<tr>
   <td>縦棒</td>
   <td><span class="myrx">|</span></td>
   <td>選択する（和集合を作る）．</td>
</tr>
<tr>
   <td>星印</td>
   <td><span class="myrx">*</span></td>
   <td>0回以上の繰り返しを指定する．</td>
</tr>
<tr>
   <td>プラス記号</td>
   <td><span class="myrx">+</span></td>
   <td>1回以上の繰り返しを指定する．</td>
</tr>
<tr>
   <td>疑問符</td>
   <td><span class="myrx">?</span></td>
   <td>0回または1回を指定する．</td>
</tr>
<tr>
   <td>左中括弧</td>
   <td><span class="myrx">{</span></td>
   <td>有限回の繰り返しを指定する．</td>
</tr>
<tr>
   <td>バックスラッシュ</td>
   <td><span class="myrx">\</span></td>
   <td>クォート（エスケープ）する．</td>
</tr>
</table>
<li>
<em>クォート</em>（または，<em>エスケープ</em>）するとは，特殊文字を通常文字に変えることを言います．特殊文字以外の通常文字をクォートしたときの意味については <a class="noline" href="#on-quoted-characters">クォート（エスケープ）について</a> を参照して下さい．
<li>
<em>右角括弧</em>（<span class="myrx">]</span>）や<em>右中括弧</em>（<span class="myrx">}</span>）は特殊文字ではないことに注意して下さい．<a class="noline" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">POSIX.1（仕様書）</a>も
<a class="noline" href="
https://manpages.debian.org/testing/manpages/regex.7.en.html
">POSIX.2（オンラインマニュアル）</a>も，これらを通常文字として分類しています．
これらは，対応する左角括弧や左丸括弧がないとき，通常文字として処理されます．一方，対応する左角括弧や左丸括弧があるときには，それぞれ，ブラケット表現を終了したり，有限回の繰り返し指定を終了するといった機能を果たします．
</ul>

<!-- ========================================================= -->
<h4 class="hdln" id="description-of-POSIX.ERE">POSIX.EREの記述形式</h4>
<ul>
<li>
POSIX.EREは，一般に
<div class="dstyle">
   $E_{11}E_{12}~\ldots~E_{1m_1}$<span class="myrx">|</span>$E_{21}E_{22}~\ldots~E_{2m_2}$<span class="myrx">|</span> $\ldots\ldots$ <span class="myrx">|</span>$E_{n1}E_{n2}~\ldots~E_{nm_n}$ &nbsp;&nbsp; （$n \geq 1$，$m_i \geq 1$）
</div>
という形式をしていて，これは
<div class="ddstyle">
\(
   \begin{array}{cl}
         & L(E_{11})\cdot{}L(E_{12})\cdot\ldots\cdot{}L(E_{1m_1}) \\
   \cup  & L(E_{21})\cdot{}L(E_{22})\cdot\ldots\cdot{}L(E_{2m_2}) \\
   \cup  & ~~~~~~\cdots\cdots \\
   \cup  & L(E_{n1})\cdot{}L(E_{n2})\cdot\ldots\cdot{}L(E_{nm_n}) \\
   \end{array}
\)
</div>
という文字列の集合を定義しています．
<li>
各<em>$E_{ij}$</em>は以下のいずれかを指定します．以下の<em>$\Sigma_{s}$</em>は特殊文字の集合を表し，<em>$\alpha$</em>は任意のPOSIX.EREを表し，<em>$E$</em>は下記の表に示した任意の表現を表しています．さらに，<em>$m$</em>と<em>$n$</em>は0以上の整数です．

<table class="symbol">
<tr>
   <th>名称</th>
   <th>$E_{ij}$</th>
   <th>意味（$L(E_{ij})$）</th>
   <th>備考（条件）</th>
</tr>
<tr>
   <td>通常文字</td>
   <td>$a$</td>
   <td>$\{a\}$</td>
   <td>$a \in \Sigma-\Sigma_{s}$</td>
</tr>
<tr>
   <td>クォートされた特殊文字</td>
   <td><span class="myrx">\</span>$c$</td>
   <td>$\{c\}$</td>
   <td>$c \in \Sigma_{s}$</td>
</tr>
<tr>
   <td>ピリオド</td>
   <td><span class="myrx">.</span></td>
   <td>$\Sigma$</td>
   <td></td>
</tr>
<tr>
   <td>ハット記号</td>
   <td><span class="myrx">^</span></td>
   <td>文字列の先頭にある空文字列の集合 $\{\varepsilon\}$</td>
   <td></td>
</tr>
<tr>
   <td>ドル記号</td>
   <td><span class="myrx">$</span></td>
   <td>文字列の末尾にある空文字列の集合 $\{\varepsilon\}$</td>
   <td></td>
</tr>
<tr>
   <td>グループ化</td>
   <td><span class="myrx">(</span>$\alpha$<span class="myrx">)</span></td>
   <td>$L(\alpha)$</td>
   <td></td>
</tr>
<tr>
   <td>0回以上の繰り返し</td>
   <td>$E$<span class="myrx">*</span></td>
   <td>$L(E)^*$</td>
   <td></td>
</tr>
<tr>
   <td>1回以上の繰り返し</td>
   <td>$E$<span class="myrx">+</span></td>
   <td>$L(E)^+$</td>
   <td></td>
</tr>
<tr>
   <td>0回または1回</td>
   <td>$E$<span class="myrx">?</span></td>
   <td>$\{\varepsilon\} \cup L(E)$</td>
   <td></td>
</tr>
<tr>
   <td>ちょうど$m$回の繰り返し</td>
   <td>$E$<span class="myrx">{</span>$m$<span class="myrx">}</span></td>
   <td>$L(E)^m$</td>
   <td>$m \geq 0$</td>
</tr>
<tr>
   <td>$m$回以上の繰り返し</td>
   <td>$E$<span class="myrx">{</span>$m$<span class="myrx">,}</span></td>
   <td>$L(E)^m \cup L(E)^{m+1} \cup L(E)^{m+2} \ldots$</td>
   <td>$m \geq 0$</td>
</tr>
<tr>
   <td>$m$回以上$n$回以下の繰り返し</td>
   <td>$E$<span class="myrx">{</span>$m$<span class="myrx">,</span>$n$<span class="myrx">}</span></td>
   <td>$L(E)^m \cup L(E)^{m+1} \cup \ldots \cup L(E)^n$</td>
   <td>$m \leq n$</td>
</tr>
<tr>
   <td><a class="noline" href="#bracket-expression">ブラケット表現</a></td>
   <td>（後述）</td>
   <td>（後述）</td>
   <td></td>
</tr>
</table>

<li>
上記の<em>繰り返し回数を表す整数</em>（$m$や$n$）は<strong>0以上RE_DUP_MAX以下の整数</strong>であるとされています．ここで，<em>RE_DUP_MAX</em>はGnu C Libraryのマクロです．Guile 3.0.7のソースコード（regex.h）を見ると，その値は$2^{15}-1$（<a class="noline" href="
https://manpages.debian.org/unstable/manpages/int16_t.3.en.html
">int16_t</a>の最大値）に設定されています．
<li>
繰り返し表現の適用対象が任意のPOSIX.ERE（$\alpha$）ではなく上記の表に示した表現（$E$）に制限されているのは，繰り返し演算が選択演算（<span class="myrx">|</span>）や連結演算（$\cdot$）よりも優先順位が高いためです．<strong>選択演算や連結演算を含む正規表現を繰り返したいときには丸括弧で囲んでグループ化しなければなりません</strong>．
<li> 
<em>各種演算の優先順位</em>は以下のように定義されています．上のほうが順位が高く，下のほうが低くなります．

<table class="symbol">
<tr>
   <th>名称</th> <th>演算</th>
</tr>
<tr>
   <td>照合記号など</td>
   <td>
   <span class="myrx">[.</span> ... <span class="myrx">.]</span>，
   <span class="myrx">[=</span> ... <span class="myrx">=]</span>，
   <span class="myrx">[:</span> ... <span class="myrx">:]</span>
   </td>
</tr>
<tr>
   <td>クォート（エスケープ）</td>
   <td><span class="myrx">\</span>$c$</td>
</tr>
<tr>
   <td>ブラケット表現</td>
   <td> <span class="myrx">[</span> ... <span class="myrx">]</span></td>
</tr>
<tr>
   <td>グループ化</td>
   <td><span class="myrx">(</span> ... <span class="myrx">)</span></td>
</tr>
<tr>
   <td>繰り返し指定</td>
   <td>
   <span class="myrx">*</span>，
   <span class="myrx">+</span>，
   <span class="myrx">?</span>，
   <span class="myrx">{</span>$m$<span class="myrx">}</span>
   <span class="myrx">{</span>$m$,<span class="myrx">}</span>
   <span class="myrx">{</span>$m$,$n$<span class="myrx">}</span>
   </td>
</tr>
<tr>
   <td>文字列の連結</td>
   <td>（注）連結演算を表す記号はありません．</td>
</tr>
<tr>
   <td>先頭と末尾</td>
   <td>
   <span class="myrx">^</span>，
   <span class="myrx">$</span>
   </td>
</tr>
<tr>
   <td>選択（和集合）</td>
   <td><span class="myrx">|</span></td>
</tr>
</table>
<li>
繰り返し表現を2重に指定したときの動作について，<a class="noline" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">POSIX.1（仕様書）</a>は<strong>未定義</strong>としていて，<a class="noline" href="
https://manpages.debian.org/testing/manpages/regex.7.en.html
">POSIX.2（オンラインマニュアル）</a>は何も述べていません．Guileでは問題なく使えるようです．
<pre class="shell">
$ <span class="mycmd">guile</span> 
GNU Guile 3.0.5
      ...... 起動メッセージ ......
guile> <span class="mycmd">(string-match "(ab){3}{1,2}" "abab")</span> 
$1 = #f
guile> <span class="mycmd">(string-match "(ab){3}{1,2}" "ababab")</span> 
$2 = #("ababab" (0 . 6) (4 . 6))
guile> <span class="mycmd">(string-match "(ab){3}{1,2}" "ababababab")</span> 
$3 = #("ababababab" (0 . 6) (4 . 6))
guile> <span class="mycmd">(string-match "(ab){3}{1,2}" "abababababab")</span> 
$4 = #("abababababab" (0 . 12) (10 . 12))
guile> 
</pre>
この実行例では，正規表現 <span class="myrx">(ab){3}{1,2}</span> を4つの文字列にマッチ（string-match）させています．この正規表現は，数学的には
   <div class="ddstyle">
      $\{$ ((ab)$^3$)$^1$ $,$ ((ab)$^3$)$^2$ $\}$ 
   $=$ $\{$ (ab)$^3$ $,$ (ab)$^6$ $\}$ 
   $=$ $\{$ ababab $,$ abababababab $\}$
   </div>
という文字列の集合を定義しているので，
"(ab)$^3$"$=$"ababab"や
"(ab)$^6$"$=$"abababababab"といった部分列がマッチするはずです．上の実行結果を見るとその通りになっています．1番目の文字列は"(ab)$^2$"なのでマッチする部分列がありません．2番目の文字列は"(ab)$^3$"なので文字列全体がマッチしています．3番目の文字列は"(ab)$^5$"なので，（最左最長原則に則って）0文字目〜5文字目までの部分列"(ab)$^3$"がマッチしています．4番目の文字列は"(ab)$^6$"なので，（最左最長原則に則って）文字列全体がマッチしています．
<li>
POSIX.EREは，<span class="myrx">a^b</span> のような，特殊文字としてのハット記号（^）を途中に指定するような表現も構文的に許しています．しかし，文字列の途中に先頭があるといった文字列はあり得ないので，そのような正規表現はどんな文字列ともマッチすることはありません．ドル記号（<span>$</span>）についても同様です．
</ul>

<!-- ===================================================== -->
<h4 class="hdln" id="grammer-of-POSIX.ERE">POSIX.EREの文法</h4>
<ul>
<li>
<a class="noline" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">POSIX.1（仕様書）</a>に掲載されているPOSIX.EREの文法を示します．
</ul>
<pre class="grammar">
;; --------------------------------------------------------------------------
;; 拡張正規表現（POSIX extended regular expression）：文字列の集合を表現する．
;; --------------------------------------------------------------------------
<span class="mysyn">extended_reg_exp</span>   ::= <span class="mysyn">ERE_branch</span>  
                      |  <span class="mysyn">extended_reg_exp</span> '|' <span class="mysyn">ERE_branch</span>

<span class="mysyn">ERE_branch</span>         ::= <span class="mysyn">ERE_expression</span>  
                      |  <span class="mysyn">ERE_branch</span> <span class="mysyn">ERE_expression</span>

<span class="mysyn">ERE_expression</span>     ::= <span class="mysyn">one_char_or_coll_elem_ERE</span>
                      |  '^'
                      |  '<span class="mybksl">$</span>'
                      |  '(' <span class="mysyn">extended_reg_exp</span> ')'
                      |  <span class="mysyn">ERE_expression</span> <span class="mysyn">ERE_dupl_symbol</span>

<span class="mysyn">one_char_or_coll_elem_ERE</span> 
                     ::= <span class="mysyn">ORD_CHAR</span>
                      |  <span class="mysyn">QUOTED_CHAR</span>
                      |  '.' 
                      |  <span class="mysyn">bracket_expression</span>

<span class="mysyn">ERE_dupl_symbol</span>    ::= '*'
                      |  '+'
                      |  '?'
                      |  '{' <span class="mysyn">DUP_COUNT</span> '}'
                      |  '{' <span class="mysyn">DUP_COUNT</span> ',' '}'
                      |  '{' <span class="mysyn">DUP_COUNT</span> ',' <span class="mysyn">DUP_COUNT</span> '}'
</pre>
<pre class="grammar">
;; --------------------------------------------------------------
;; 通常文字（特殊文字以外の文字）
;; --------------------------------------------------------------
<span class="mysyn">ORD_CHAR</span>   ::= 下記の特殊文字以外の文字
</pre>
<pre class="grammar">
;; --------------------------------------------------------------
;; 特殊文字
;; --------------------------------------------------------------
<span class="mysyn">SPEC_CHAR</span>  ::= '^'         ;; 文字列の先頭
              |  '.'         ;; 任意の文字
              |  '['         ;; ブラケット表現の開始
              |  '$'         ;; 文字列の末尾
              |  '('         ;; グループ化
              |  ')'         ;; グループ化
              |  '|'         ;; 選択（和集合）
              |  '*'         ;; 0回以上の繰り返し（クリーネ閉包）
              |  '+'         ;; 1回以上の繰り返し
              |  '?'         ;; 0回または1回
              |  '{'         ;; 有限回の繰り返し指定の開始
              |  '\'         ;; クォート（エスケープ）
</pre>
<pre class="grammar">
;; --------------------------------------------------------------
;; クォート（エスケープ）された文字（特殊文字を通常文字にする）
;; --------------------------------------------------------------
<span class="mysyn">QUOTED_CHAR</span>  ::= '\^'  |  '\.'  |  '\['  |  '\$'  |  '\('  |  '\)'
                |  '\|'  |  '\*'  |  '\+'  |  '\?'  |  '\{'  |  '\\'
</pre>
<ul>
<li>
（参考）特殊文字以外の通常文字をクォートしたときの意味については <a class="noline" href="#on-quoted-characters">クォート（エスケープ）について</a> を参照して下さい．
</ul>
<pre class="grammar">
;; --------------------------------------------------------------
;; 繰り返し指定の整数
;; --------------------------------------------------------------
<span class="mysyn">DUP_COUNT</span>   ::= 0以上RE_DUP_MAX以下の整数
</pre>
<ul>
<li>
（参考）Guile 3.0.7のソースコード（regex.h）では RE_DUP_MAX $= 2^{15}-1$ です．
</ul>
</section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section>
<h3 class="section" id="bracket-expression">ブラケット表現</h3>

<!-- =================================================== -->
<h4 class="hdln" id="description-of-bracket-expression">ブラケット表現の記述形式</h4>
<ul>
<li>
<em>ブラケット表現</em>（bracket expression）は，<strong>文字集合（$\Sigma$の部分集合）を定義する</strong>ための正規表現です．以下のいずれかの形式によって記述します．
<table class="symbol">
<tr>
   <th>記述形式（$\alpha$）</th>
   <th>意味（$L(\alpha)$）</th>
   <th>備考（条件）</th>
</tr>
<tr>
   <td> <span class="myrx">[</span>$C_0C_1 \cdots C_n$<span class="myrx">]</span></td>
   <td>$L(C_0) \cup L(C_1) \cup \cdots \cup L(C_n)$</td>
   <td>$C_0\not=$<span class="myrx">^</span></td>
</tr>
<tr>
   <td> <span class="myrx">[^</span>$C_1 \cdots C_n$<span class="myrx">]</span></td>
   <td>$\Sigma - (L(C_1) \cup \cdots \cup L(C_n))$</td>
   <td></td>
</tr>
</table>
ここで：
   <ul>
   <li>
<strong>左角括弧</strong>（<span class="myrx">[</span>）と<strong>右角括弧</strong>（<span class="myrx">]</span>）は，それぞれ，<strong>ブラケット表現の開始と終了</strong>を表します．
   <li>
   <strong>ハット</strong>（<span class="myrx">^</span>）は，$\Sigma$を全体集合としたときの<strong>補集合演算</strong>を表します．
   <li> ブラケット表現の先頭（1番目の形式の$C_0$，または，2番目の形式の$C_1$）以外の$C_i$は右角括弧（<span class="myrx">]</span>）ではないとします．
右角括弧（<span class="myrx">]</span>）はブラケット表現の終了を示すためのものなので，ブラケット表現の途中で指定できないのは明らかでしょう．ただし，ブラケット表現の先頭には右角括弧を指定できます（下記の<a class="noline" href="#right-bracket">右角括弧</a>を参照）．
   </ul>
一番目の形式を<em>matching list expression</em>と呼び，2番目の形式を<em>non-matching list expression</em>と呼びます．
<li>
各<em>$C_i$</em>は以下のいずれかを指定します．以下では，<em>$\Sigma_1$</em>$=\Sigma-\{$'^'$,$'-'$,$']'$\}$とします．ここで，ハット（'^'），ハイフン（'-'），右角括弧（']'）はブラケット表現における<a class="noline" href="#meta-characters">メタ文字（後述）</a>です．さらに，
<div class="ddstyle">
   $\Gamma = \{$<span class="myrx">[.</span>$c$<span class="myrx">.]</span> $\mid$ $c \in \Sigma \}$
   &nbsp;&nbsp;&nbsp;
   (注：以下に示す<strong>照合記号表現の全体</strong>）
</div> 
とします．
<table class="symbol">
<tr>
   <th>名称</th>
   <th>$C_i$</th> 
   <th>意味（$L(C_i)$）</th>
   <th>備考（条件）</th>
</tr>
<tr>
   <td>文字</td>
   <td>$a$</td>
   <td>$\{a\}$</td>
   <td>$a \in \Sigma_1$</td>
</tr>
<tr>
   <td>ハット記号</td>
   <td><span class="myrx">^</span></td>
   <td>$\{$'^'$\}$</td>
   <td>下記参照</td>
</tr>
<tr>
   <td>ハイフン</td>
   <td><span class="myrx">-</span></td>
   <td>$\{$'-'$\}$</td>
   <td>下記参照</td>
</tr>
<tr>
   <td>右角括弧</td>
   <td><span class="myrx">]</span></td>
   <td>$\{$']'$\}$</td>
   <td>下記参照</td>
</tr>
<tr>
   <td>照合記号表現</td>
   <td><span class="myrx">[.</span>$c$<span class="myrx">.]</span></td>
   <td>$\{c\}$</td>
   <td>$c \in \Sigma$</td>
</tr>
<tr>
   <td>等価クラス表現</td>
   <td><span class="myrx">[=</span>$c$<span class="myrx">=]</span></td>
   <td>$c$と等価な文字の全体</td>
   <td>$c \in \Sigma$</td>
</tr>
<tr>
   <td>文字クラス表現</td>
   <td><span class="myrx">[:alnum:]</span> など</td>
   <td>詳細は後述．</td>
   <td></td>
</tr>
<tr>
   <td>範囲表現</td>
   <td>$d$<span class="myrx">-</span>$e$</td>
   <td>$d$以上$e$以下の文字の全体</td>
   <td>$d\in \Sigma_1 \cup \{$'^'$\} \cup \Gamma$<br>
       $e \in \Sigma_1 \cup \{$'^'$,$'-'$\} \cup \Gamma$</td>
</tr>
</table>
<li>
上記の
<a class="noline" href="#meta-characters">メタ文字</a>（ハット記号，ハイフン，右角括弧）は，それらが<strong>普通の文字として処理される場合</strong>を示しています．
<li>
範囲表現の始点（$d$）に関する条件は，もっとも一般的な場合の条件を示しています．文脈によっては，始点（$d$）にハイフンや右角括弧を指定できます．なお，終点（$e$）に関する条件は文脈に依存して変化することはありません．
<li>
ブラケット表現の中で一つの文字を複数回指定してもエラーにはなりません．何回指定しても1回指定したものとして処理されます．例えば，ブラケット表現の<span class="myrx">[aaa]</span>は，文字'a'を3回指定していますが，$\{$'a'$\}$という文字集合を表します．
</ul>

<!-- ======================================================= -->
<h4 class="hdln" id="characeters-in-bracket-expression">ブラケット表現における文字の分類</h4>
<ul>
<li>
ブラケット表現の中では，通常文字／特殊文字といった分類や機能はキャンセルされ，文字の分類・機能がリセットされます．つまり，ブラケット表現の中と外では文字の処理の仕方（文字の分類・機能）がまったく異なります．
<li>
ブラケット表現の中では，以下に述べる<strong>メタ文字以外のすべての文字は普通の文字として処理されます</strong>．そのため，例えば，星印（*）やプラス記号（+）やピリオド（.）やバックスラッシュ（\）は普通の文字として処理されます．さらに，メタ文字も，文脈に応じて普通の文字として処理されます（下記参照）．
<li>
<em id="meta-characters">メタ文字</em>（meta character）は以下の3つがあり，ブラケット表現の中で特殊な機能を果たします．

 <table class="symbol">
   <tr>
      <th>名称</th> <th>文字</th> <th>機能</th>
   </tr>
   <tr>
      <td>ハット</td>   <td><span class="myrx">^</span></td> <td>$\Sigma$を全体集合とした補集合を取る</td>
   </tr>
   <tr>
      <td>ハイフン</td> <td><span class="myrx">-</span></td> <td>文字の範囲を指定する</td>
   </tr>
   <tr>
      <td>右角括弧</td> <td><span class="myrx">]</span></td> <td>ブラケット表現を終了する</td>
   </tr>
</table>
$C_i$がメタ文字のときには，文脈に応じて解釈が変わります．普通の文字として扱われたり，メタ文字の機能を発揮したりします．さらに，以下で説明するように，メタ文字ごとに解釈の仕方が異なります．
<li><em id="hat-symbol">ハット記号</em>（^）は，ブラケット表現の$C_0$のところに指定したときにはメタ文字（補集合演算）として処理されます（つまり，そのときのブラケット表現は2番目の形式として処理されます）．一方，$C_1$〜$C_n$のところに指定したときには普通の文字として処理されます．
<li>
<em id="hyphen-symbol">ハイフン</em>（-）は，ブラケット表現の先頭（1番目の形式の$C_0$，または，2番目の形式の$C_1$）や，ブラケット表現の末尾（$C_n$）や，範囲表現の終点（上記の$e$）に指定したときには，普通の文字として処理されます．これら以外のところに指定したときには，メタ文字（範囲指定）として処理されます．<strong>ハイフンは，メタ文字として処理されるとき単独で（つまり，$C_i$の一つとして）指定することはできません</strong>．範囲表現の一部として指定しなければなりません．
<li>
<em id="right-bracket">右角括弧</em>（]）は，ブラケット表現の先頭（1番目の形式の$C_0$，または，2番目の形式の$C_1$）に指定したときには普通の文字として処理されます．一方，先頭以外に指定したときにはメタ文字（ブラケット表現の終了）として処理されます．
</ul>

<!-- ===================================================== -->
<h4 class="hdln" id="collating-symbol">照合記号表現</h4>
<ul>
<li>
POSIX.EREの<em>照合記号表現</em>は，<strong>ブラケット表現の中で単一の照合要素からなる集合を指定する</strong>ためのものです．次の形式によって表現します．
<div class="ddstyle">
   <span class="myrx">[.</span>$\,c\,$<span class="myrx">.]</span>
</div>
ここで：
   <ul>
   <li> <span class="myrx">[.</span>は左角括弧とピリオドの組み合わせです．
   <li> <span class="myrx">.]</span>はピリオドと右角括弧の組み合わせです．
   <li> $c$は任意の照合要素です（注：すべての文字を指定できます）．
   </ul>
この表現は照合要素$c$だけからなる集合 $\{c\}$ を定義しています．
<li>
<em>照合要素</em>は，文字かまたは文字として機能する文字列のことです（詳細は省略します）．文字以外の照合要素（2文字以上で構成される照合要素）は実行環境が採用している<strong>ロケール（の定義ファイル）において定義されていなければなりません</strong>．ロケールにおいて定義されていないものは使用できません．残念ながら，筆者の環境（Debian 11）のロケール（ja_JP）は，文字以外の照合要素を定義していないため，文字以外の照合要素は使用できません．
<li>
一方，照合要素にはメタ文字も含まれるので，<strong>ブラケット表現の中でメタ文字を普通の文字として指定するために利用できます</strong>．つまり，照合記号表現の中ではメタ文字も普通の文字として処理されます．例えば，ブラケット表現 <span class="myrx">[[.^.][.-.][.].]]</span> は，メタ文字からなる集合$\{$'^'$,$'-'$,$']'$\}$を表します．
</ul>

<!-- ==================================================== -->
<h4 class="hdln" id="equivalence-class">等価クラス表現</h4>
<ul>
<li> 
POSIX.EREの<em>等価クラス表現</em>は，<strong>ブラケット表現の中で等価な照合要素からなる集合を指定する</strong>ためのものです．次の形式によって表現します．
<div class="ddstyle">
   <span class="myrx">[=</span>$c$<span class="myrx">=]</span>
</div>
ここで：
   <ul>
   <li> <span class="myrx">[=</span>は左角括弧と等号の組み合わせです．
   <li> <span class="myrx">=]</span>は等号と右角括弧の組み合わせです．
   <li> $c$は任意の照合要素です．
   </ul>
この表現は照合要素$c$と等価な照合要素からなる集合を表しています．
<li>
任意の照合要素$c$に対して，$c$は$c$自身と等価です（同値関係の反射性）．従って，上記の集合には$c$自身が必ず入ります．一方，<strong>自分自身以外の等価性はロケール（の定義ファイル）の中で定義しなけばなりません</strong>．従って，上記の集合に$c$以外に何が入るかはロケール（の定義ファイル）に依存して決まります．
<li>
残念ながら，筆者の環境（Debian 11）のロケール（ja_JP）は，2つの異なる照合要素間の等価性を何も定義していません．従って，筆者の環境では，$c$が何であろうとも，上記の等価クラスは$c$だけからなる集合$\{c\}$を表すことになります．
</ul>

<!-- ==================================================== -->
<h4 class="hdln" id="character-class">文字クラス表現</h4>
<ul>
<li> 
POSIX.EREは以下に示すような文字集合を用意しています．これらを<em>文字クラス</em>（character class）と呼んでいます．
<table class="symbol">
<tr>
   <th>文字クラス</th>
   <th>意味</th>
</tr>
<tr>
   <td><span class="myrx">[:alnum:]</span></td>
   <td>$L($<span class="myrx">[:alpha:]</span>$) \cup L($<span class="myrx">[:digit:]</span>$)$</td>
</tr>
<tr>
   <td><span class="myrx">[:alpha:]</span></td>
   <td>アルファベットに相当する文字の集合</td>
</tr>
<tr>
   <td><span class="myrx">[:blank:]</span></td>
   <td>空白とタブの集合</td>
</tr>
<tr>
   <td><span class="myrx">[:cntrl:]</span></td>
   <td>制御文字の集合</td>
</tr>
<tr>
   <td><span class="myrx">[:digit:]</span></td>
   <td>数字の集合</td>
</tr>
<tr>
   <td><span class="myrx">[:graph:]</span></td>
   <td>印字可能な文字の集合（注：空白を除く）</td>
</tr>
<tr>
   <td><span class="myrx">[:lower:]</span></td>
   <td>小文字に相当する文字の集合</td>
</tr>
<tr>
   <td><span class="myrx">[:print:]</span></td>
   <td>印字可能な文字の集合（注：空白を含む）</td>
</tr>
<tr>
   <td><span class="myrx">[:punct:]</span></td>
   <td>$L($<span class="myrx">[:graph:]</span>$)-L($<span class="myrx">[:alnum:]</span>$)$</td>
</tr>
<tr>
   <td><span class="myrx">[:space:]</span></td>
   <td>スペースに相当する文字の集合</td>
</tr>
<tr>
   <td><span class="myrx">[:upper:]</span></td>
   <td>大文字に相当する文字の集合</td>
</tr>
<tr>
   <td><span class="myrx">[:xdigit:]</span></td>
   <td>16進数で使用する文字の集合</td>
</tr>
</table>
<li>
各文字クラスの中身はロケールに応じて変化します．筆者の環境（Debian 11）のロケール（ja_JP）では，次のファイルの中で定義されています．
   <ul>
   <li> /usr/share/i18n/locales/i18n_ctype
   <li> /usr/share/i18n/locales/ja_JP
   </ul>
例えば，文字クラス <span class="myrx">[[:alpha:]]</span> は，英字だけでなく，半角のカタカナや全角のひらがな・カタカナ・漢字をすべて含んでいるようです．以下に簡単な実行例を示します．
<pre class="shell">
$ <span class="mycmd">guile</span> 
GNU Guile 3.0.5
      ...... 起動メッセージ ......
guile> <span class="mycmd">(string-match "[[:alpha:]]" " ｱ ")</span> 
$1 = #(" ｱ " (1 . 2))
guile> <span class="mycmd">(string-match "[[:alpha:]]" " あ ")</span> 
$2 = #(" あ " (1 . 2))
guile> <span class="mycmd">(string-match "[[:alpha:]]" " ア ")</span>
$3 = #(" ア " (1 . 2))
guile> <span class="mycmd">(string-match "[[:alpha:]]" " 亜 ")</span>
$4 = #(" 亜 " (1 . 2))
guile> <span class="mycmd">(string-match "[[:alpha:]]" " @ ")</span>
$5 = #f
guile> <span class="mycmd">(string-match "[[:alpha:]]" " ＠ ")</span>
$6 = #f
guile> 
</pre>
この実行例では，カタカナなどの前後に空白を入れた文字列を文字クラス <span class="myrx">[[:alpha:]]</span> にマッチ（string-match）させています．半角のカタカナや全角のひらがな・カタカナ・漢字はマッチしていますが，半角や全角の特殊記号はマッチしていません．

<!-- i18_ctype
[:space:]
<U0009>..<U000D>;<U0020>;<U1680>;<U2000>..<U2006>;<U2008>..<U200A>;/
   <U2028>..<U2029>;<U205F>;<U3000>


<li>
[:blank:]
   <U0009>;<U0020>;<U1680>;<U2000>..<U2006>;<U2008>..<U200A>;<U205F>;/
   <U3000>
-->
</ul>

<!-- =========================================================== -->
<h4 class="hdln" id="range-expression">範囲表現</h4>
<ul>
<li> 
<em>範囲表現</em> $d$<span class="myrx">-</span>$e$ は$d$以上$e$以下の文字からなる集合を表しています．$d$を範囲表現の<em>始点</em>（starting point）と呼び，$e$を<em>終点</em>（ending point）と呼びます．始点と終点の間はハイフン（マイナス記号）です．
<li>
始点（$d$）と終点（$e$）には，メタ文字を除いて，あらゆる文字が指定できます．文脈によってメタ文字も指定できるのですが，その規則については<a class="noline" href="#meta-characters">メタ文字</a>（各メタ文字の解釈）を参照して下さい．
<li>
始点（$d$）と終点（$e$）には，あらゆる照合記号表現が指定できます．従って，メタ文字を始点や終点に指定したいときには，照合記号表現を利用するとより安全と言えるでしょう．
<li>
始点（$d$）に指定した文字の順位は終点（$e$）に指定した文字の順位よりも小さくなければなりません．ただし，文字の間の順序はロケールに応じて変化します ...... と言いたいところですが，厳密にはよく分かりません．この点については <a class="noline" href="#on-locale">ロケールについて</a>（文字の順序）を参照して下さい．
<li>
（注意）文字の順序は<strong>文字コードの大小順とは限りません</strong>．
</ul>

<!-- ================================================= -->
<h4 class="hdln" id="on-hyphen">ハイフンについて</h4>
<ul>
<li>
ブラケット表現の中でハイフンを見たら，ほぼ直ちに範囲表現を表していると考えてしまいます．しかし，そういった考えがしばしば混乱を引き起こすことがあります．
<li>
正規表現の中でハイフンを見たら，範囲表現のことはいったん忘れて，まずハイフンそのものを解釈することが肝要です．つまり，範囲表現のことはいったん忘れて，
メタ文字の<a class="noline" href="#hyphen-symbol">ハイフンの解釈</a>のところで述べた規則に則って，そのハイフンが普通の文字として処理されるのかメタ文字として処理されるのかを判断します．そのハイフンがメタ文字として処理されるときに改めて範囲表現として認識するようにします．例えば：
   <ul>
   <li>
   ブラケット表現<span class="myrx">[--@]</span>において，1番目のハイフンは（ブラケット表現の先頭なので）普通の文字として処理され，2番目のハイフンはメタ文字として処理されます．従って，このブラケット表現は'-'以上'@'以下の文字からなる集合を表します．
   <li>
   ブラケット表現<span class="myrx">[+--@]</span>において，1番目のハイフンはメタ文字として処理され，2番目のハイフンは（範囲表現の終点なので）普通の文字として処理されます．従って，このブラケット表現は'+'以上'-'以下の文字と'@'からなる集合を表します．
   <li>
   ブラケット表現<span class="myrx">[+---]</span>において，1番目のハイフンはメタ文字として処理され，2番目のハイフンは（範囲表現の終点なので）普通の文字として処理され，3番目のハイフンは（ブラケット表現の末尾なので）普通の文字として処理されます．従って，このブラケット表現は'+'以上'-'以下の文字と'-'からなる集合を表します（注：末尾の'-'は誤りではありませんがムダです）．
   <li>
   ブラケット表現<span class="myrx">[a-h-z]</span>において，両方のハイフンはメタ文字として処理されます．従って，これらのハイフンは範囲表現 <span class="myrx">a-h</span> と <span class="myrx">h-z</span> の一部になっています．しかし，これら2つの範囲表現は終点と始点が重なっていて（それぞれが単独の$C_i$として成立していないので）文法的に正しくありません．
   <li>
   ブラケット表現<span class="myrx">[^-a-h-]</span>において，1番目のハイフンは（ブラケット表現の先頭なので）普通の文字として処理され，2番目のハイフンはメタ文字として処理され，3番目のハイフンは（ブラケット表現の末尾なので）普通の文字として処理されます．従って，このブラケット表現は'-'と'a'以上'h'以下の文字と'-'からなる集合の補集合（ただし，全体集合は文字集合$\Sigma$）を表します（注：ハイフンを2度指定することは誤りではありませんがムダです）．
   </ul>
</ul>

<!-- ============================================================ -->
<h4 class="hdln" id="grammar-bracket-expression">ブラケット表現の文法</h4>
<ul>
<li>
<a class="noline" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">POSIX.1（仕様書）</a>に掲載されているブラケット表現の文法を示します．
</ul>

<pre class="grammar">
;; --------------------------------------------------------------
;; ブラケット表現（bracket expression）：文字集合を表現する． 
;; --------------------------------------------------------------
<span class="mysyn">bracket_expression</span> ::= '[' <span class="mysyn">matching_list</span> ']'
                      |  '[' <span class="mysyn">non-matching_list</span> ']'

<span class="mysyn">matching_list</span>      ::= <span class="mysyn">bracket_list</span>

<span class="mysyn">non-matching_list</span>   ::= '^' <span class="mysyn">bracket_list</span>

<span class="mysyn">bracket_list</span>       ::= <span class="mysyn">follow_list</span>
                      |  <span class="mysyn">follow_list</span> '-'

<span class="mysyn">follow_list</span>        ::= <span class="mysyn">expression_term</span>
                      |  <span class="mysyn">follow_list</span> <span class="mysyn">expression_term</span>

<span class="mysyn">expression_term</span>    ::= <span class="mysyn">single_expression</span>
                      |  <span class="mysyn">range_expression</span>

<span class="mysyn">single_expression</span>  ::= <span class="mysyn">end_range</span>
                      |  <span class="mysyn">character_class</span>
                      |  <span class="mysyn">equivalence_class</span>

<span class="mysyn">range_expression</span>   ::= <span class="mysyn">start_range</span> <span class="mysyn">end_range</span>
                      |  <span class="mysyn">start_range</span> '-'

<span class="mysyn">start_range</span>        ::= <span class="mysyn">end_range</span> '-'

<span class="mysyn">end_range</span>          ::= <span class="mysyn">COLL_ELEM_SINGLE</span>
                      |  <span class="mysyn">collating_symbol</span>

<span class="mysyn">collating_symbol</span>   ::= <span class="mysyn">Open_dot COLL_ELEM_SINGLE</span> <span class="mysyn">Dot_close</span>
                      |  <span class="mysyn">Open_dot</span> <span class="mysyn">COLL_ELEM_MULTI</span> <span class="mysyn">Dot_close</span>
                      |  <span class="mysyn">Open_dot</span> <span class="mysyn">META_CHAR</span> <span class="mysyn">Dot_close</span>

<span class="mysyn">equivalence_class</span>  ::= <span class="mysyn">Open_equal</span> <span class="mysyn">COLL_ELEM_SINGLE</span> <span class="mysyn">Equal_close</span>
                      | <span class="mysyn">Open_equal</span> <span class="mysyn">COLL_ELEM_MULTI</span> <span class="mysyn">Equal_close</span>

<span class="mysyn">character_class</span>    ::= <span class="mysyn">Open_colon</span> <span class="mysyn">class_name</span> <span class="mysyn">Colon_close</span>
</pre>
<pre class="grammar">
;; --------------------------------------------------------------
;; 照合要素（collating element）：
;; --------------------------------------------------------------
<span class="mysyn">COLL_ELEM_SINGLE</span>  ::= メタ文字以外の文字（照合要素）
<span class="mysyn">COLL_ELEM_MULTI</span>   ::= 2文字以上からなる照合要素
</pre>
<pre class="grammar">
;; --------------------------------------------------------------
;; メタ文字（meta characters）：
;; --------------------------------------------------------------
<span class="mysyn">META_CHAR</span>   ::= '^'      ;; 文字集合の補集合演算を表す
               |  '-'      ;; 範囲指定
               |  ']'      ;; ブラケット表現の終了
</pre>
<ul>
<li>
（参考）上記の文法は<a class="noline" href="https://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap09.html">POSIX.1（仕様書）</a>の本文の説明との間に以下のような齟齬があります．
   <ul>
   <li> 
   上記の文法に従うと，ブラケット表現の先頭に右角括弧（']'）やハイフン（'-'）を指定できません．
   <li>
   上記の文法に従うと，$C_1$〜$C_n$のところにハット記号（'^'）を指定できません．
   <li>
   上記の文法に従うと，等価クラスにメタ文字を指定できません．でも，仕様書の本文には，そういった禁止事項は述べられていません．
   </ul>
1番目と3番目は文法を少し変更すれば修正可能と思いますが，2番目は簡単に修正できそうもありません．
<li>
ハイフンの扱い方や構文カテゴリー（品詞）の名前が雑だったりして，ちょっと分かりにくい文法です．
</ul>
</section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<section id="miscellaneous">
<h3 class="section">その他色々</h3>
<ul>
<li>
（注意）以下の内容は<strong>あやふやです</strong>．あまり信用しないで下さい．あやふやと言わざるを得ない理由は，正確な仕様が（少なくとも今の筆者には）見つけられないからです．
</ul>

<!-- ==================================================== -->
<h4 class="hdln" id="on-locale">ロケールについて</h4>
<ul>
<li>
正規表現の機能のうち，少なくとも次の機能はロケール（の言語に関する定義）に依存します．
   <ul>
   <li> 文字の順序
   <li> 照合要素
   <li> 等価クラス
   <li> 正規表現の中で利用可能な既存の文字クラス
   </ul>
これらはいずれも
<a class="noline" href="
https://manpages.debian.org/testing/manpages/locale.5.en.html
">
ロケール定義ファイル
</a>
の中で定義されています．例えば，筆者の環境（日本語版Debian 11）のロケール（ja_JP.UTF-8）では，文字の順序はUnicode符号位置やUTF-8の文字コードの大小順ではなく，JIS規格などの文字コード表に従って定義されているようです．さらに，2文字以上で構成される照合要素や等価クラスは定義されていないので，それらに関連する機能は使うことはできません．
<li>
<em>文字の順序</em>は範囲表現の中で使用します．その範囲表現に関して<a class="noline" href="
https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html
">POSIX.1（仕様書）</a>は次のように述べています（下記の強調は筆者によるものです）．
<blockquote>
In the POSIX locale, a range expression represents the set of collating elements that fall between two elements in the collation sequence, inclusive. <em>In other locales, a range expression has unspecified behavior</em>: strictly conforming applications shall not rely on whether the range expression is valid, or on the set of collating elements matched.
</blockquote>
この記述をそのまま信じるならば，例えば筆者のロケール（ja_JP）の場合，範囲表現に関してどういった処理が行われるかは不明ということになります．

<li>
Debian 11の場合，ロケール定義ファイルは次の通りです．
   <ul>
   <li> /usr/share/i18n/locale/ja_jp
   </ul>
これはテキストファイルなので中身を見ることができます．既存の文字クラスは，このファイルの中のLC_CTYPEカテゴリーのところで定義されていて，jspace，jhira，jkata，jkanji，jdigitの5つの文字クラスが定義されています．残りの3つの機能は，LC_COLLATEカテゴリーのところで定義されるのですが，そこには文字の順序だけが定義されていて，照合要素（collating-element）や文字の間の等価性（symbol-equivalence）は定義されていません．
<li>
jspaceなどの文字クラスが定義されているのですが，残念ながら，これらは利用できないようです．以下に実行例を示します．
<pre class="shell">
$ <span class="mycmd">guile</span> 
GNU Guile 3.0.5
      ...... 起動メッセージ ......
guile> <span class="mycmd">(string-match "[[:jspace:]]" "　　")</span> 
ice-9/boot-9.scm:1669:16: In procedure raise-exception:
In procedure make-regexp: 無効な文字クラス名です

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
guile [1]> 
</pre>
利用できない理由は不明です．

</ul>

<!-- ===================================================== -->
<h4 class="hdln" id="on-quoted-characters">クォート（エスケープ）について</h4>
<ul>
<li>
1〜9の数字をクォートした場合（<span class="myrx">\1</span>，<span class="myrx">\2</span>，...， <span class="myrx">\9</span>），
<a class="noline" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">POSIX.1（仕様書）</a>も<a class="noline" href="
https://manpages.debian.org/testing/manpages/regex.7.en.html
">POSIX.2（オンラインマニュアル）</a>もともに，それを前方参照（back-reference）として処理すると定めています．ただし，これは基本正規表現に関する機能として述べられていて，拡張正規表現のところでは何も述べていません．そのため，厳密に仕様に従うのであれば，拡張正規表現において前方参照（back-reference）は使えないことになります．ただ，Guileで試してみると使えます（<a class="noline" href="#on-back-reference">前方参照（back-reference）について</a>を参照して下さい）．
<li>
その他の通常文字をクォートした場合（例えば，<span class="myrx">\a</span>，<span class="myrx">\b</span>，<span class="myrx">\c</span>，... など），
<a class="noline" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">POSIX.1（仕様書）</a>は「その解釈は未定義である」としていて，<a class="noline" href="
https://manpages.debian.org/testing/manpages/regex.7.en.html
">POSIX.2（オンラインマニュアル）</a>は「通常文字として処理される（ただし，実装依存）」としています．一方，Guile 3.0.7のソースコード（regcomp.c内のpeek_token関数）を見ると，下記のクォートされた文字は特別な機能を発揮します．
<table class="symbol">
<tr>
   <th>クォート文字</th> <th>意味（機能）</th> <th>備考</th>
</tr>
<tr>
   <td><span class="myrx">\b</span></td>
   <td>単語の境界にマッチする</td>
   <td></td>
</tr>
<tr>
   <td><span class="myrx">\B</span></td>
   <td>単語の境界以外（の文字境界）にマッチする</td>
   <td></td>
</tr>
<tr>
   <td><span class="myrx">\w</span></td>
   <td><span class="myrx">[_[:alnum:]]</span>と等価</td>
   <td><span class="myrx">_</span> はアンダースコア</td>
</tr>
<tr>
   <td><span class="myrx">\W</span></td>
   <td><span class="myrx">[^_[:alnum:]]</span>と等価</td>
   <td>同上</td>
</tr>
<tr>
   <td><span class="myrx">\&lt;</span></td>
   <td>単語の先頭にマッチする</td>
   <td></td>
</tr>
<tr>
   <td><span class="myrx">\&gt;</span></td>
   <td>単語の末尾にマッチする</td>
   <td></td>
</tr>
<tr>
   <td><span class="myrx">\s</span></td>
   <td><span class="myrx">[[:space:]]</span>と等価</td>
   <td></td>
</tr>
<tr>
   <td><span class="myrx">\S</span></td>
   <td><span class="myrx">[^[:space:]]</span>と等価</td>
   <td></td>
</tr>
<tr>
   <td><span class="myrx">\`</span></td>
   <td>文字列の先頭にマッチする</td>
   <td><span class="myrx">^</span>と等価</td>
</tr>
<tr>
   <td><span class="myrx">\'</span></td>
   <td>文字列の末尾にマッチする</td>
   <td><span class="myrx">$</span>と等価</td>
</tr>
<tr>
   <td><span class="myrx">\</span>$k$</td>
   <td>前方参照（back-reference）</td>
   <td>$k=$1$,$2$, \ldots ,$9</td>
</tr>
</table>
<li>
上記以外のクォートされた文字は普通の文字として処理されます（下記参照）．
<li>
各機能を判断するにあたって，Guileを使って試してみた経験の他に，<a class="noline" href="
https://manpages.debian.org/unstable/grep/grep.1.en.html
">grepのオンラインマニュアル</a>を参照しています．そのgrepのオンラインマニュアルによれば，<em>単語</em>（word）とは，数字，英字，アンダースコアーによって構成される文字列のことを言います．ただ，どのように構成すべきかについは何も述べていません．Guileで試してみると，数字から始まっていても，あるいは，数字列（数字だけの文字列）だったとしても単語として認識するようです．以下は簡単な実行例です．
<pre class="shell">
$ <span class="mycmd">guile</span> 
GNU Guile 3.0.5
      ...... 起動メッセージ ......
guile> <span class="mycmd">(string-match "\\b" "#123#")</span> 
$1 = #("#123#" (1 . 1))
guile> <span class="mycmd">(string-match "\\>" "#123#")</span> 
$2 = #("#123#" (4 . 4))
guile> 
</pre>
1番目の実行例は，部分列"123"の直前の境界にマッチしています．2番目の実行例は，部分列"123"の直後の境界にマッチしています．これらの結果から"123"を単語として扱っていることが分かります．
<li>
<em>back-reference</em>を「後方参照」と訳すのが一般的なようです．しかし，以下に示すようにGuileのエラーメッセージは「前方参照」と表示します．
<pre class="shell">
$ <span class="mycmd">guile</span> 
GNU Guile 3.0.5
      ...... 起動メッセージ ......
guile> <span class="mycmd">(string-match "\\1" "a")</span> 
ice-9/boot-9.scm:1669:16: In procedure raise-exception:
In procedure make-regexp: 無効な前方参照です

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
guile [1]> 
</pre>
このノートはGuileに関するものなので，Guileの訳語を使っています．
<li>
（参考）以下のプログラムは，ASCIIコード表の印字可能な文字を対象に，上記の一覧に示した文字だけが特殊な機能を果たすことを確認するためのものです．下記のtest-quote手続きは，文字コードchcodeを受け取って，そのコードの文字$c$（下記プログラム内のch）に対して以下のような処理を行います．
   <ol>
   <li> 正規表現 <span class="myrx">\</span>$c$（下記プログラム内のregex）を作ります．
   <li> 文字コードがchcode$-1$の文字 $c'$，文字$c$，文字コードがchcode$+1$の文字 $c''$の3つの文字からなる文字列 $c'cc''$（下記プログラム内のstr）を作ります．なお，$c'$と$c''$は単に$c$と異なる文字を適当に用意しているだけで，それ以外の意図はありません．
   <li> 上記の文字列（str）を正規表現（regex）にマッチ（string-match）させ，その結果を適当な形式（format）にまとめて返します．
   </ol>
各文字に対する結果は以下のいずれかの形式でまとめられます．
   <ol type="a">
   <li> <span style="color:blue">regex:<span class="myrx">\</span>$c$&nbsp;&nbsp;str:$c'cc''$&nbsp;&nbsp;result:#f </span><br>
この形式は文字列$c'cc''$が正規表現<span class="myrx">\</span>$c$にマッチしなかったことを表します．従って，この場合には，正規表現 <span class="myrx">\</span>$c$ が普通の文字として処理されなかったこと（何らかの特別な機能を発揮したこと）を示します．
   <li> <span style="color:blue">regex:<span class="myrx">\</span>$c$&nbsp;&nbsp;str:$c'cc''$&nbsp;&nbsp;result:($s$ . $t$)&nbsp;"$d$"</span><br>
この形式は文字列$c'cc''$が正規表現 <span class="myrx">\</span>$c$ にマッチしたことを示しています．$s$と$t$は，それぞれ，文字列$c'cc''$内のマッチした開始位置と終了位置を表します．さらに，"$d$"はマッチした部分列を表しています（ただし，これは参考情報にすぎません）．従って，正規表現 <span class="myrx">\</span>$c$ が普通の文字として処理されるときには，文字列$c'cc''$の文字$c$（先頭から見て1文字目の文字）にマッチするので，その場合には$s=1$かつ$t=2$（かつ$d=c$）となります．逆に言えば，$s\not=1$または$t\not=2$のとき，正規表現 <span class="myrx">\</span>$c$ が普通の文字として処理されなかったこと（何らかの特別な機能を発揮したこと）を示します．
   </ol>
<pre class="list">
#!/usr/bin/guile \
-e main -s
!#
;; test-quote.scm

(use-modules (ice-9 regex)
             (srfi srfi-11))

(define DISPLAY-ALL #f)

(define (main args)
  (let ((alllst '()) (anomalst '()))
    (let loop ((chcode #x20))
      (when (and (&lt; chcode #x7f))
        (if (not (&lt;= #x31 chcode #x39))
          (let-values (((form flag) (test-quote chcode)))
            (set! alllst (cons form alllst))
            (when flag (set! anomalst (cons form anomalst)))))
        (loop (1+ chcode))))
    (when DISPLAY-ALL 
      (display alllst)
      (display "\n----------------------\n"))
    (display (reverse anomalst)) (newline)))

(define (test-quote chcode)
  (let* ((ch    (integer->char chcode))
         (regex (string-append "\\" (string ch)))
         (str   (string (integer->char (1- chcode))
                        ch
                        (integer->char (1+ chcode))))
         (match (string-match regex str)))
    (values 
     (format #f "~a~a~a~s~a~a\n"  
             "regex:"    regex 
             "  str:"    str 
             "  result:" 
             (if match
                 (format #f "~a ~s"
                         (cons (match:start match) (match:end match))
                         (match:substring match))
                 match))
     (not (and match 
               (= (match:start match) 1) 
               (= (match:end match) 2))))))
</pre>
main手続きは，ASCIIコード表の数字（1〜9）を除く印字可能な文字（ASCIIコードで #x20〜#x30 と #x3a〜#x7e）に関してtest-quote手続きを実行します．DISPLAY-ALLが#tのときには，これらのすべての文字に関する結果を表示します．DISPLAY-ALLが#fのときには，<span class="myrx">\</span>$c$が普通の文字として処理されなかった文字$c$の結果だけを表示します．以下は上記のプログラムの実行結果です．
<pre class="shell">
$ <span class="mycmd">./test-quote.scm</span>   
(regex:\'  str:"&'("  result:(3 . 3) ""
 regex:\&lt;  str:";&lt;="  result:#f
 regex:\&gt;  str:"=&gt;?"  result:#f
 regex:\B  str:"ABC"  result:(1 . 1) ""
 regex:\S  str:"RST"  result:(0 . 1) "R"
 regex:\W  str:"VWX"  result:#f
 regex:\`  str:"_`a"  result:(0 . 0) ""
 regex:\b  str:"abc"  result:(0 . 0) ""
 regex:\s  str:"rst"  result:#f
 regex:\w  str:"vwx"  result:(0 . 1) "v"
)
</pre>
上記の結果（文字の一覧）は先に示した一覧表と一致します．なお，1〜9の数字については「無効な前方参照」といったエラーが発生します．
<pre class="shell">
$ <span class="mycmd">guile</span> 
GNU Guile 3.0.5
      ...... 起動メッセージ ......
guile> <span class="mycmd">(string-match "\\1" "abc")</span> 
ice-9/boot-9.scm:1669:16: In procedure raise-exception:
In procedure make-regexp: 無効な前方参照です

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
guile [1]> 
</pre>
</ul>

<!-- ========================================================= -->
<h4 class="hdln" id="on-back-reference">前方参照（back-reference）について</h4>
<ul>
<li>
以下は余談（negligible）です．
<li>
前方参照（back-reference）の定義を掲載します．なお，前方参照（back-reference）は基本正規表現（BRE）の機能なので，丸括弧はエスケープされた文字として示されています．
<blockquote>
<a class="noline" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">POSIX.1（仕様書）</a><br>
The back-reference expression '\n' shall match the same (possibly empty) string of characters as was matched by a subexpression enclosed between <span>"\("</span> and <span>"\)"</span> preceding the '\n'. The character 'n' shall be a digit from 1 through 9, specifying the nth subexpression (the one that begins with the nth <span>"\("</span> from the beginning of the pattern and ends with the corresponding paired <span>"\)"</span> ). The expression is invalid if less than n subexpressions precede the '\n'. The string matched by a contained subexpression shall be within the string matched by the containing subexpression. If the containing subexpression does not match, or if there is no match for the contained subexpression within the string matched by the containing subexpression, then back-reference expressions corresponding to the contained subexpression shall not match. When a subexpression matches more than one string, a back-reference expression corresponding to the subexpression shall refer to the last matched string. 
</blockquote>
<blockquote>
<a class="noline" href="
https://manpages.debian.org/testing/manpages/regex.7.en.html
">POSIX.2（オンラインマニュアル）</a><br>
Finally, there is one new type of atom, a back reference: '\' followed by a nonzero decimal digit d matches the same sequence of characters matched by the dth parenthesized subexpression (numbering subexpressions by the positions of their opening parentheses, left to right), so that, for example, <span>"\([</span>bc<span>]\)\1"</span> matches "bb" or "cc" but not "bc".
</blockquote>

<li>
前方参照（back-reference）は面白いアイデアだと思いますが，
<a class="noline" href="
https://manpages.debian.org/testing/manpages/regex.7.en.html
">POSIX.2（オンラインマニュアル）</a>は次のようなことを述べています（注：正規表現の形式を拡張版に変更しています）．
<blockquote>
Back references are a dreadful botch, posing major problems for efficient implementations. They are also somewhat vaguely defined (does <span class="myrx">a((b)*\2)*d</span> match "abbbd"?). Avoid using them.
</blockquote>
「dreadful botch」のニュアンス（ひどさの度合い）は分かりませんが，「Avoid using them」はかなり強い提言だと思います．前方参照（back-reference）は使わないほうがよいようです．
<li>
数学的な観点から言うと，前方参照（back-reference）は（数学的な意味の）正規表現の能力を超えています．例えば，正規表現 <span class="myrx">(.*)\1</span> は $\{ ww \mid w \in \Sigma^* \}$ という文字列の集合を定義していて，この集合は文脈自由ですらありません（これについては形式言語理論の教科書を参照して下さい）．このようなことから，前方参照（back-reference）は正規表現の元来の意図を超えていると言えます．
<li>
ちなみに，前方参照（back-reference）の定義より，正規表現 <span class="myrx">a((b)*\2)*d</span> は <span class="myrx">a((b)*b)*d</span> （注：<span class="myrx">\2</span>を<span class="myrx">b</span>に置き換えたもの）と等価です．さらに，正規表現 <span class="myrx">((b)*b)*</span> は <span class="myrx">b*</span> と数学的に等価です．従って，数学的な解釈では，正規表現 <span class="myrx">a((b)*\2)*d</span> は <span class="myrx">ab*d</span> と等価なので，
   <div class="dstyle">
       $\{$ ab$^k$d $\mid$ $k \geq 0$ $\}$
   $=$ $\{$ ad$,$ abd$,$ abbd$,$ abbbd$,$ $\ldots$ $\}$    
   </div>
といった集合を定義しています．従って，文字列"abbbd"は正規表現 <span class="myrx">a((b)*\2)*d</span> に（数学的には）明らかにマッチします．実際に試してみると次のようになります．
<pre class="shell">
$ <span class="mycmd">guile</span> 
GNU Guile 3.0.5
      ...... 起動メッセージ ......
guile> <span class="mycmd">(string-match "a((b)*\\2)*d" "abbbd")</span> 
$1 = #("abbbd" (0 . 5) (1 . 4) (2 . 3))
guile> 
</pre>
なので，一見したところでは，上の丸括弧内のコメントは何か勘違いしているように筆者には見えます．いま一つ，何を言いたいのか理解できません．おそらく，筆者が理解していない技術的な背景があるのだろうと思います．とにもかくにも，筆者は，数学的に解釈した結果と一致してくれれば文句はありません．
<li>
前方参照（back-reference）はプロでも間違い易いもののようです．<a class="noline" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html">POSIX.1（仕様書）</a>の前方参照（bac-reference）の説明のところに次のような具体例があります
（ただし，基本正規表現を拡張版に書き換えています）．
<blockquote>
   ..., the expression <span class="myrx">(a(b)*)*\2</span> fails to match 'abab',...
</blockquote>
正規表現 <span class="myrx">(a(b)*)*\2</span> は <span class="myrx">(a(b)*)*b</span> と等価（なはず）なので，以下に示すように，文字列"abab"はこの正規表現にマッチします．
<pre class="shell">
guile> <span class="mycmd">(string-match "(a(b)*)*\\2" "abab")</span>  
$4 = #("abab" (0 . 4) (2 . 3) (1 . 2))
guile> 
</pre>

</ul>
</section>


<div id="thatsall">(おしまい)</div>

</div> <!-- END of main division -->
</body>
</html>

